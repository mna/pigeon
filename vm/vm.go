package vm

import (
	"bytes"
	"fmt"
)

// ϡtheProgram is the variable that holds the program generated by the
// builder for the input PEG.
var ϡtheProgram *ϡprogram

// ϡsentinel is a type used to define sentinel values that shouldn't
// be equal to something else.
type ϡsentinel int

const (
	// ϡmatchFailed is a sentinel value used to indicate a match failure.
	ϡmatchFailed ϡsentinel = iota
)

const (
	// stack IDs, used in PUSH and POP's first argument
	ϡpstackID = iota + 1
	ϡlstackID
	ϡvstackID
	ϡistackID
)

// special values that may be pushed on the V stack.
var ϡvSpecialValues = []interface{}{
	nil,
	ϡmatchFailed,
	[]interface{}(nil),
}

type ϡmemoizedResult struct {
	v  interface{}
	pt ϡsvpt
}

// ϡprogram is the data structure that is generated by the builder
// based on an input PEG. It contains the program information required
// to execute the grammar using the vm.
type ϡprogram struct {
	instrs []ϡinstr

	// lists
	ms []ϡmatcher
	as []func(*ϡvm) (interface{}, error)
	bs []func(*ϡvm) (bool, error)
	ss []string

	// instrToRule is the mapping of an instruction index to a rule
	// identifier (or display name) in the ss list:
	//
	// ss[instrToRule[instrIndex]] == name of the rule
	//
	// Since instructions are limited to 65535, the size of this slice
	// is bounded to a reasonable number.
	instrToRule []int
}

type ϡvm struct {
	// input
	filename string
	parser   *ϡparser

	// options
	debug   bool
	memoize bool
	recover bool
	// TODO : no bounds checking option (for stacks)? benchmark to see if it's worth it.

	// program data
	pc    int
	depth int
	pg    *ϡprogram

	// stacks
	p       ϡpstack
	l       ϡlstack
	v       ϡvstack
	i       ϡistack
	varSets []map[string]interface{}

	// TODO: memoization...

	// error list
	errs errList
}

// setOptions applies the options in sequence on the vm. It returns the
// vm to allow for chaining calls.
func (v *ϡvm) setOptions(opts []Option) *ϡvm {
	for _, opt := range opts {
		opt(v)
	}
	return v
}

func (v *ϡvm) addErr(err error) {
	v.addErrAt(err, v.parser.pt.position)
}

func (v *ϡvm) addErrAt(err error, pos position) {
	var buf bytes.Buffer
	if v.filename != "" {
		buf.WriteString(v.filename)
	}
	if buf.Len() > 0 {
		buf.WriteString(":")
	}
	buf.WriteString(fmt.Sprintf("%s", pos))
	// TODO : add rule ID or display name
	// if len(p.rstack) > 0 {
	// 	if buf.Len() > 0 {
	// 		buf.WriteString(": ")
	// 	}
	// 	rule := p.rstack[len(p.rstack)-1]
	// 	if rule.displayName != "" {
	// 		buf.WriteString("rule " + rule.displayName)
	// 	} else {
	// 		buf.WriteString("rule " + rule.name)
	// 	}
	// }
	pe := &parserError{Inner: err, ϡprefix: buf.String()}
	v.errs.ϡadd(pe)
}

// run executes the provided program in this VM, and returns the result.
func (v *ϡvm) run(pg *ϡprogram) (interface{}, error) {
	v.pg = pg
	// TODO : add a vm.init() or reset()?
	ret := v.dispatch()

	// if the match failed, translate that to a nil result and make
	// sure it returns an error
	if ret == ϡmatchFailed {
		ret = nil
		if len(v.errs) == 0 {
			v.addErr(errNoMatch)
		}
	}

	return ret, v.errs.ϡerr()
}

// dispatch is the proper execution method of the VM, it loops over
// the instructions and executes each opcode.
func (v *ϡvm) dispatch() interface{} {
	for {
		// fetch and decode the instruction
		instr := v.pg.instrs[v.pc]
		op, n, a0, a1, a2 := instr.decode()

		// increment program counter
		v.pc++

		switch op {
		case ϡopCall:
		case ϡopCallA:
		case ϡopCallB:
		case ϡopCumulOrF:
			va, vb := v.v.pop(), v.v.pop()
			if va == ϡmatchFailed {
				v.v.push(ϡmatchFailed)
				break
			}
			switch vb := vb.(type) {
			case []interface{}:
				vb = append(vb, va)
				v.v.push(vb)
			case ϡsentinel:
				v.v.push([]interface{}{va})
			default:
				panic(fmt.Sprintf("invalid %s value type on the V stack: %T", op, vb))
			}
		case ϡopDebug:
		case ϡopExit:
			return v.v.pop()
		case ϡopFalseIfF:
			top := v.v.pop()
			v.v.push(top != ϡmatchFailed)
		case ϡopJump:
			v.pc = a0
		case ϡopJumpIfF:
			if top := v.v.peek(); top == ϡmatchFailed {
				v.pc = a0
			}
		case ϡopJumpIfT:
			if top := v.v.peek(); top != ϡmatchFailed {
				v.pc = a0
			}
		case ϡopMatch:
			start := v.parser.pt
			if a0 >= len(v.pg.ms) {
				panic(fmt.Sprintf("invalid %s argument: %d", op, a0))
			}
			m := v.pg.ms[a0]
			if ok := m.match(v.parser); ok {
				v.v.push(v.parser.sliceFrom(start))
				break
			}
			v.v.push(ϡmatchFailed)
			v.parser.pt = start
		case ϡopPop:
			switch a0 {
			case ϡlstackID:
				v.l.pop()
			case ϡpstackID:
				v.p.pop()
			default:
				panic(fmt.Sprintf("invalid %s argument: %d", op, a0))
			}
		case ϡopPopVJumpIfF:
			if top := v.v.peek(); top == ϡmatchFailed {
				v.v.pop()
				v.pc = a0
			}
		case ϡopPush:
			switch a0 {
			case ϡpstackID:
				v.p.push(v.parser.pt)
			case ϡistackID:
				v.i.push(a1)
			case ϡvstackID:
				if a1 >= len(ϡvSpecialValues) {
					panic(fmt.Sprintf("invalid %s V stack argument: %d", op, a1))
				}
				v.v.push(ϡvSpecialValues[a1])
			case ϡlstackID:
				ar := make([]int, n)
				src := []int{0, 0, a2, a1}
				for i := 0; i < n; i++ {
					lsrc := len(src)
					ar[i] = src[lsrc-1]
					src = src[:lsrc-1]
					if lsrc-1 == 0 && i < n-1 {
						// need more
						instr := v.pg.instrs[v.pc]
						a0, a1, a2, a3 := instr.decodeLs()
						src = append(src, a3, a2, a1, a0)
						v.pc++
					}
				}
				v.l.push(ar)
			default:
				panic(fmt.Sprintf("invalid %s argument: %d", op, a0))
			}
		case ϡopRestore:
			pt := v.p.pop()
			v.parser.pt = pt
		case ϡopRestoreIfF:
			pt := v.p.pop()
			if top := v.v.peek(); top == ϡmatchFailed {
				v.parser.pt = pt
			}
		case ϡopReturn:
			ix := v.i.pop()
			v.depth--
			if v.depth < 0 {
				panic("negative call depth")
			}
			v.pc = ix
			// TODO : clean-up varSet
		case ϡopStoreIfT:
		case ϡopTakeLOrJump:
			ix := v.l.take()
			if ix < 0 {
				v.pc = a0
				break
			}
			v.i.push(ix)
		case ϡopTrueIfF:
			top := v.v.pop()
			v.v.push(top == ϡmatchFailed)
		default:
			panic(fmt.Sprintf("unknown opcode %s", op))
		}
	}
}
